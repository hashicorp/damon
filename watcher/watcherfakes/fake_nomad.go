// Code generated by counterfeiter. DO NOT EDIT.
package watcherfakes

import (
	"sync"

	"github.com/hashicorp/nomad/api"
	"github.com/hcjulz/damon/models"
	"github.com/hcjulz/damon/nomad"
	"github.com/hcjulz/damon/watcher"
)

type FakeNomad struct {
	AddressStub        func() string
	addressMutex       sync.RWMutex
	addressArgsForCall []struct {
	}
	addressReturns struct {
		result1 string
	}
	addressReturnsOnCall map[int]struct {
		result1 string
	}
	AllocationsStub        func(*nomad.SearchOptions) ([]*models.Alloc, error)
	allocationsMutex       sync.RWMutex
	allocationsArgsForCall []struct {
		arg1 *nomad.SearchOptions
	}
	allocationsReturns struct {
		result1 []*models.Alloc
		result2 error
	}
	allocationsReturnsOnCall map[int]struct {
		result1 []*models.Alloc
		result2 error
	}
	DeploymentsStub        func(*nomad.SearchOptions) ([]*models.Deployment, error)
	deploymentsMutex       sync.RWMutex
	deploymentsArgsForCall []struct {
		arg1 *nomad.SearchOptions
	}
	deploymentsReturns struct {
		result1 []*models.Deployment
		result2 error
	}
	deploymentsReturnsOnCall map[int]struct {
		result1 []*models.Deployment
		result2 error
	}
	JobAllocsStub        func(string, *nomad.SearchOptions) ([]*models.Alloc, error)
	jobAllocsMutex       sync.RWMutex
	jobAllocsArgsForCall []struct {
		arg1 string
		arg2 *nomad.SearchOptions
	}
	jobAllocsReturns struct {
		result1 []*models.Alloc
		result2 error
	}
	jobAllocsReturnsOnCall map[int]struct {
		result1 []*models.Alloc
		result2 error
	}
	JobsStub        func(*nomad.SearchOptions) ([]*models.Job, error)
	jobsMutex       sync.RWMutex
	jobsArgsForCall []struct {
		arg1 *nomad.SearchOptions
	}
	jobsReturns struct {
		result1 []*models.Job
		result2 error
	}
	jobsReturnsOnCall map[int]struct {
		result1 []*models.Job
		result2 error
	}
	LogsStub        func(string, string, string, <-chan struct{}) (<-chan *api.StreamFrame, <-chan error)
	logsMutex       sync.RWMutex
	logsArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 <-chan struct{}
	}
	logsReturns struct {
		result1 <-chan *api.StreamFrame
		result2 <-chan error
	}
	logsReturnsOnCall map[int]struct {
		result1 <-chan *api.StreamFrame
		result2 <-chan error
	}
	NamespacesStub        func(*nomad.SearchOptions) ([]*models.Namespace, error)
	namespacesMutex       sync.RWMutex
	namespacesArgsForCall []struct {
		arg1 *nomad.SearchOptions
	}
	namespacesReturns struct {
		result1 []*models.Namespace
		result2 error
	}
	namespacesReturnsOnCall map[int]struct {
		result1 []*models.Namespace
		result2 error
	}
	StreamStub        func(nomad.Topics, uint64) (<-chan *api.Events, error)
	streamMutex       sync.RWMutex
	streamArgsForCall []struct {
		arg1 nomad.Topics
		arg2 uint64
	}
	streamReturns struct {
		result1 <-chan *api.Events
		result2 error
	}
	streamReturnsOnCall map[int]struct {
		result1 <-chan *api.Events
		result2 error
	}
	TaskGroupsStub        func(string, *nomad.SearchOptions) ([]*models.TaskGroup, error)
	taskGroupsMutex       sync.RWMutex
	taskGroupsArgsForCall []struct {
		arg1 string
		arg2 *nomad.SearchOptions
	}
	taskGroupsReturns struct {
		result1 []*models.TaskGroup
		result2 error
	}
	taskGroupsReturnsOnCall map[int]struct {
		result1 []*models.TaskGroup
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNomad) Address() string {
	fake.addressMutex.Lock()
	ret, specificReturn := fake.addressReturnsOnCall[len(fake.addressArgsForCall)]
	fake.addressArgsForCall = append(fake.addressArgsForCall, struct {
	}{})
	stub := fake.AddressStub
	fakeReturns := fake.addressReturns
	fake.recordInvocation("Address", []interface{}{})
	fake.addressMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNomad) AddressCallCount() int {
	fake.addressMutex.RLock()
	defer fake.addressMutex.RUnlock()
	return len(fake.addressArgsForCall)
}

func (fake *FakeNomad) AddressCalls(stub func() string) {
	fake.addressMutex.Lock()
	defer fake.addressMutex.Unlock()
	fake.AddressStub = stub
}

func (fake *FakeNomad) AddressReturns(result1 string) {
	fake.addressMutex.Lock()
	defer fake.addressMutex.Unlock()
	fake.AddressStub = nil
	fake.addressReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeNomad) AddressReturnsOnCall(i int, result1 string) {
	fake.addressMutex.Lock()
	defer fake.addressMutex.Unlock()
	fake.AddressStub = nil
	if fake.addressReturnsOnCall == nil {
		fake.addressReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.addressReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeNomad) Allocations(arg1 *nomad.SearchOptions) ([]*models.Alloc, error) {
	fake.allocationsMutex.Lock()
	ret, specificReturn := fake.allocationsReturnsOnCall[len(fake.allocationsArgsForCall)]
	fake.allocationsArgsForCall = append(fake.allocationsArgsForCall, struct {
		arg1 *nomad.SearchOptions
	}{arg1})
	stub := fake.AllocationsStub
	fakeReturns := fake.allocationsReturns
	fake.recordInvocation("Allocations", []interface{}{arg1})
	fake.allocationsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) AllocationsCallCount() int {
	fake.allocationsMutex.RLock()
	defer fake.allocationsMutex.RUnlock()
	return len(fake.allocationsArgsForCall)
}

func (fake *FakeNomad) AllocationsCalls(stub func(*nomad.SearchOptions) ([]*models.Alloc, error)) {
	fake.allocationsMutex.Lock()
	defer fake.allocationsMutex.Unlock()
	fake.AllocationsStub = stub
}

func (fake *FakeNomad) AllocationsArgsForCall(i int) *nomad.SearchOptions {
	fake.allocationsMutex.RLock()
	defer fake.allocationsMutex.RUnlock()
	argsForCall := fake.allocationsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNomad) AllocationsReturns(result1 []*models.Alloc, result2 error) {
	fake.allocationsMutex.Lock()
	defer fake.allocationsMutex.Unlock()
	fake.AllocationsStub = nil
	fake.allocationsReturns = struct {
		result1 []*models.Alloc
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) AllocationsReturnsOnCall(i int, result1 []*models.Alloc, result2 error) {
	fake.allocationsMutex.Lock()
	defer fake.allocationsMutex.Unlock()
	fake.AllocationsStub = nil
	if fake.allocationsReturnsOnCall == nil {
		fake.allocationsReturnsOnCall = make(map[int]struct {
			result1 []*models.Alloc
			result2 error
		})
	}
	fake.allocationsReturnsOnCall[i] = struct {
		result1 []*models.Alloc
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) Deployments(arg1 *nomad.SearchOptions) ([]*models.Deployment, error) {
	fake.deploymentsMutex.Lock()
	ret, specificReturn := fake.deploymentsReturnsOnCall[len(fake.deploymentsArgsForCall)]
	fake.deploymentsArgsForCall = append(fake.deploymentsArgsForCall, struct {
		arg1 *nomad.SearchOptions
	}{arg1})
	stub := fake.DeploymentsStub
	fakeReturns := fake.deploymentsReturns
	fake.recordInvocation("Deployments", []interface{}{arg1})
	fake.deploymentsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) DeploymentsCallCount() int {
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	return len(fake.deploymentsArgsForCall)
}

func (fake *FakeNomad) DeploymentsCalls(stub func(*nomad.SearchOptions) ([]*models.Deployment, error)) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = stub
}

func (fake *FakeNomad) DeploymentsArgsForCall(i int) *nomad.SearchOptions {
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	argsForCall := fake.deploymentsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNomad) DeploymentsReturns(result1 []*models.Deployment, result2 error) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = nil
	fake.deploymentsReturns = struct {
		result1 []*models.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) DeploymentsReturnsOnCall(i int, result1 []*models.Deployment, result2 error) {
	fake.deploymentsMutex.Lock()
	defer fake.deploymentsMutex.Unlock()
	fake.DeploymentsStub = nil
	if fake.deploymentsReturnsOnCall == nil {
		fake.deploymentsReturnsOnCall = make(map[int]struct {
			result1 []*models.Deployment
			result2 error
		})
	}
	fake.deploymentsReturnsOnCall[i] = struct {
		result1 []*models.Deployment
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) JobAllocs(arg1 string, arg2 *nomad.SearchOptions) ([]*models.Alloc, error) {
	fake.jobAllocsMutex.Lock()
	ret, specificReturn := fake.jobAllocsReturnsOnCall[len(fake.jobAllocsArgsForCall)]
	fake.jobAllocsArgsForCall = append(fake.jobAllocsArgsForCall, struct {
		arg1 string
		arg2 *nomad.SearchOptions
	}{arg1, arg2})
	stub := fake.JobAllocsStub
	fakeReturns := fake.jobAllocsReturns
	fake.recordInvocation("JobAllocs", []interface{}{arg1, arg2})
	fake.jobAllocsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) JobAllocsCallCount() int {
	fake.jobAllocsMutex.RLock()
	defer fake.jobAllocsMutex.RUnlock()
	return len(fake.jobAllocsArgsForCall)
}

func (fake *FakeNomad) JobAllocsCalls(stub func(string, *nomad.SearchOptions) ([]*models.Alloc, error)) {
	fake.jobAllocsMutex.Lock()
	defer fake.jobAllocsMutex.Unlock()
	fake.JobAllocsStub = stub
}

func (fake *FakeNomad) JobAllocsArgsForCall(i int) (string, *nomad.SearchOptions) {
	fake.jobAllocsMutex.RLock()
	defer fake.jobAllocsMutex.RUnlock()
	argsForCall := fake.jobAllocsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNomad) JobAllocsReturns(result1 []*models.Alloc, result2 error) {
	fake.jobAllocsMutex.Lock()
	defer fake.jobAllocsMutex.Unlock()
	fake.JobAllocsStub = nil
	fake.jobAllocsReturns = struct {
		result1 []*models.Alloc
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) JobAllocsReturnsOnCall(i int, result1 []*models.Alloc, result2 error) {
	fake.jobAllocsMutex.Lock()
	defer fake.jobAllocsMutex.Unlock()
	fake.JobAllocsStub = nil
	if fake.jobAllocsReturnsOnCall == nil {
		fake.jobAllocsReturnsOnCall = make(map[int]struct {
			result1 []*models.Alloc
			result2 error
		})
	}
	fake.jobAllocsReturnsOnCall[i] = struct {
		result1 []*models.Alloc
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) Jobs(arg1 *nomad.SearchOptions) ([]*models.Job, error) {
	fake.jobsMutex.Lock()
	ret, specificReturn := fake.jobsReturnsOnCall[len(fake.jobsArgsForCall)]
	fake.jobsArgsForCall = append(fake.jobsArgsForCall, struct {
		arg1 *nomad.SearchOptions
	}{arg1})
	stub := fake.JobsStub
	fakeReturns := fake.jobsReturns
	fake.recordInvocation("Jobs", []interface{}{arg1})
	fake.jobsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) JobsCallCount() int {
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	return len(fake.jobsArgsForCall)
}

func (fake *FakeNomad) JobsCalls(stub func(*nomad.SearchOptions) ([]*models.Job, error)) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = stub
}

func (fake *FakeNomad) JobsArgsForCall(i int) *nomad.SearchOptions {
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	argsForCall := fake.jobsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNomad) JobsReturns(result1 []*models.Job, result2 error) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = nil
	fake.jobsReturns = struct {
		result1 []*models.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) JobsReturnsOnCall(i int, result1 []*models.Job, result2 error) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = nil
	if fake.jobsReturnsOnCall == nil {
		fake.jobsReturnsOnCall = make(map[int]struct {
			result1 []*models.Job
			result2 error
		})
	}
	fake.jobsReturnsOnCall[i] = struct {
		result1 []*models.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) Logs(arg1 string, arg2 string, arg3 string, arg4 <-chan struct{}) (<-chan *api.StreamFrame, <-chan error) {
	fake.logsMutex.Lock()
	ret, specificReturn := fake.logsReturnsOnCall[len(fake.logsArgsForCall)]
	fake.logsArgsForCall = append(fake.logsArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
		arg4 <-chan struct{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.LogsStub
	fakeReturns := fake.logsReturns
	fake.recordInvocation("Logs", []interface{}{arg1, arg2, arg3, arg4})
	fake.logsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) LogsCallCount() int {
	fake.logsMutex.RLock()
	defer fake.logsMutex.RUnlock()
	return len(fake.logsArgsForCall)
}

func (fake *FakeNomad) LogsCalls(stub func(string, string, string, <-chan struct{}) (<-chan *api.StreamFrame, <-chan error)) {
	fake.logsMutex.Lock()
	defer fake.logsMutex.Unlock()
	fake.LogsStub = stub
}

func (fake *FakeNomad) LogsArgsForCall(i int) (string, string, string, <-chan struct{}) {
	fake.logsMutex.RLock()
	defer fake.logsMutex.RUnlock()
	argsForCall := fake.logsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeNomad) LogsReturns(result1 <-chan *api.StreamFrame, result2 <-chan error) {
	fake.logsMutex.Lock()
	defer fake.logsMutex.Unlock()
	fake.LogsStub = nil
	fake.logsReturns = struct {
		result1 <-chan *api.StreamFrame
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeNomad) LogsReturnsOnCall(i int, result1 <-chan *api.StreamFrame, result2 <-chan error) {
	fake.logsMutex.Lock()
	defer fake.logsMutex.Unlock()
	fake.LogsStub = nil
	if fake.logsReturnsOnCall == nil {
		fake.logsReturnsOnCall = make(map[int]struct {
			result1 <-chan *api.StreamFrame
			result2 <-chan error
		})
	}
	fake.logsReturnsOnCall[i] = struct {
		result1 <-chan *api.StreamFrame
		result2 <-chan error
	}{result1, result2}
}

func (fake *FakeNomad) Namespaces(arg1 *nomad.SearchOptions) ([]*models.Namespace, error) {
	fake.namespacesMutex.Lock()
	ret, specificReturn := fake.namespacesReturnsOnCall[len(fake.namespacesArgsForCall)]
	fake.namespacesArgsForCall = append(fake.namespacesArgsForCall, struct {
		arg1 *nomad.SearchOptions
	}{arg1})
	stub := fake.NamespacesStub
	fakeReturns := fake.namespacesReturns
	fake.recordInvocation("Namespaces", []interface{}{arg1})
	fake.namespacesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) NamespacesCallCount() int {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	return len(fake.namespacesArgsForCall)
}

func (fake *FakeNomad) NamespacesCalls(stub func(*nomad.SearchOptions) ([]*models.Namespace, error)) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = stub
}

func (fake *FakeNomad) NamespacesArgsForCall(i int) *nomad.SearchOptions {
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	argsForCall := fake.namespacesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNomad) NamespacesReturns(result1 []*models.Namespace, result2 error) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	fake.namespacesReturns = struct {
		result1 []*models.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) NamespacesReturnsOnCall(i int, result1 []*models.Namespace, result2 error) {
	fake.namespacesMutex.Lock()
	defer fake.namespacesMutex.Unlock()
	fake.NamespacesStub = nil
	if fake.namespacesReturnsOnCall == nil {
		fake.namespacesReturnsOnCall = make(map[int]struct {
			result1 []*models.Namespace
			result2 error
		})
	}
	fake.namespacesReturnsOnCall[i] = struct {
		result1 []*models.Namespace
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) Stream(arg1 nomad.Topics, arg2 uint64) (<-chan *api.Events, error) {
	fake.streamMutex.Lock()
	ret, specificReturn := fake.streamReturnsOnCall[len(fake.streamArgsForCall)]
	fake.streamArgsForCall = append(fake.streamArgsForCall, struct {
		arg1 nomad.Topics
		arg2 uint64
	}{arg1, arg2})
	stub := fake.StreamStub
	fakeReturns := fake.streamReturns
	fake.recordInvocation("Stream", []interface{}{arg1, arg2})
	fake.streamMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) StreamCallCount() int {
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	return len(fake.streamArgsForCall)
}

func (fake *FakeNomad) StreamCalls(stub func(nomad.Topics, uint64) (<-chan *api.Events, error)) {
	fake.streamMutex.Lock()
	defer fake.streamMutex.Unlock()
	fake.StreamStub = stub
}

func (fake *FakeNomad) StreamArgsForCall(i int) (nomad.Topics, uint64) {
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	argsForCall := fake.streamArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNomad) StreamReturns(result1 <-chan *api.Events, result2 error) {
	fake.streamMutex.Lock()
	defer fake.streamMutex.Unlock()
	fake.StreamStub = nil
	fake.streamReturns = struct {
		result1 <-chan *api.Events
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) StreamReturnsOnCall(i int, result1 <-chan *api.Events, result2 error) {
	fake.streamMutex.Lock()
	defer fake.streamMutex.Unlock()
	fake.StreamStub = nil
	if fake.streamReturnsOnCall == nil {
		fake.streamReturnsOnCall = make(map[int]struct {
			result1 <-chan *api.Events
			result2 error
		})
	}
	fake.streamReturnsOnCall[i] = struct {
		result1 <-chan *api.Events
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) TaskGroups(arg1 string, arg2 *nomad.SearchOptions) ([]*models.TaskGroup, error) {
	fake.taskGroupsMutex.Lock()
	ret, specificReturn := fake.taskGroupsReturnsOnCall[len(fake.taskGroupsArgsForCall)]
	fake.taskGroupsArgsForCall = append(fake.taskGroupsArgsForCall, struct {
		arg1 string
		arg2 *nomad.SearchOptions
	}{arg1, arg2})
	stub := fake.TaskGroupsStub
	fakeReturns := fake.taskGroupsReturns
	fake.recordInvocation("TaskGroups", []interface{}{arg1, arg2})
	fake.taskGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNomad) TaskGroupsCallCount() int {
	fake.taskGroupsMutex.RLock()
	defer fake.taskGroupsMutex.RUnlock()
	return len(fake.taskGroupsArgsForCall)
}

func (fake *FakeNomad) TaskGroupsCalls(stub func(string, *nomad.SearchOptions) ([]*models.TaskGroup, error)) {
	fake.taskGroupsMutex.Lock()
	defer fake.taskGroupsMutex.Unlock()
	fake.TaskGroupsStub = stub
}

func (fake *FakeNomad) TaskGroupsArgsForCall(i int) (string, *nomad.SearchOptions) {
	fake.taskGroupsMutex.RLock()
	defer fake.taskGroupsMutex.RUnlock()
	argsForCall := fake.taskGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNomad) TaskGroupsReturns(result1 []*models.TaskGroup, result2 error) {
	fake.taskGroupsMutex.Lock()
	defer fake.taskGroupsMutex.Unlock()
	fake.TaskGroupsStub = nil
	fake.taskGroupsReturns = struct {
		result1 []*models.TaskGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) TaskGroupsReturnsOnCall(i int, result1 []*models.TaskGroup, result2 error) {
	fake.taskGroupsMutex.Lock()
	defer fake.taskGroupsMutex.Unlock()
	fake.TaskGroupsStub = nil
	if fake.taskGroupsReturnsOnCall == nil {
		fake.taskGroupsReturnsOnCall = make(map[int]struct {
			result1 []*models.TaskGroup
			result2 error
		})
	}
	fake.taskGroupsReturnsOnCall[i] = struct {
		result1 []*models.TaskGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeNomad) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addressMutex.RLock()
	defer fake.addressMutex.RUnlock()
	fake.allocationsMutex.RLock()
	defer fake.allocationsMutex.RUnlock()
	fake.deploymentsMutex.RLock()
	defer fake.deploymentsMutex.RUnlock()
	fake.jobAllocsMutex.RLock()
	defer fake.jobAllocsMutex.RUnlock()
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	fake.logsMutex.RLock()
	defer fake.logsMutex.RUnlock()
	fake.namespacesMutex.RLock()
	defer fake.namespacesMutex.RUnlock()
	fake.streamMutex.RLock()
	defer fake.streamMutex.RUnlock()
	fake.taskGroupsMutex.RLock()
	defer fake.taskGroupsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNomad) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ watcher.Nomad = new(FakeNomad)
